Хорошо, переписываю описание паттерна **Адаптер** в запрошенном Markdown-стиле, без примеров кода на Python (их можно будет добавить позже).

---

### 1. Что такое «Адаптер» (Adapter)

**Адаптер** — структурный паттерн, который **позволяет объектам с несовместимыми интерфейсами работать вместе**. Он действует как **переходник** между двумя объектами, преобразуя вызовы одного интерфейса в вызовы другого.

Это позволяет:

*   "обернуть" существующий класс или стороннюю библиотеку в новый интерфейс, понятный клиенту,
*   использовать старый код с новыми системами (или наоборот), не меняя исходный код адаптируемого компонента,
*   избежать переписывания клиентского кода при смене используемой библиотеки с другим API.

`Клиент ──▶ Адаптер (реализует Target Interface) ──▶ Adaptee (адаптируемый объект/система)`

#### Зачем он нужен

| Боль                                                                                    | Как помогает Adapter                                                                        |
| :-------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------ |
| Есть класс/библиотека, но её интерфейс (методы, аргументы) не подходит клиенту.         | Создаём Адаптер, который "переводит" вызовы клиента в вызовы Adaptee с нужными параметрами. |
| Нужно использовать несколько разных классов с похожей функциональностью, но разными API. | Пишем Адаптеры для каждого, приводя их к единому, ожидаемому клиентом интерфейсу (Target). |
| Хочется заменить старую библиотеку на новую без переписывания всего клиентского кода.   | Пишем Адаптер для новой библиотеки, имитирующий интерфейс старой (или ожидаемый клиентом).  |

> ✂️ **Короткая аналогия** (и хватит): вы приехали в другую страну с ноутбуком. Розетка (`Adaptee`) не подходит к вашей вилке (ожидания `Client`). Вы используете **переходник** (`Адаптер`), чтобы всё заработало, не перепаивая ни вилку, ни розетку.

---

### 2. Мини‑теория: участники

| Роль                   | Суть                                                                                                |
| :--------------------- | :-------------------------------------------------------------------------------------------------- |
| **Client**             | Класс, который хочет использовать другой объект (`Adaptee`), но ожидает определённый интерфейс (`Target`). |
| **Target**             | Интерфейс (часто неявный в Python, например, набор методов), который ожидает `Client`.             |
| **Adapter**            | Класс, который реализует интерфейс `Target` и внутри себя вызывает методы `Adaptee`. Связующее звено. |
| **Adaptee**            | Существующий класс (или функция, модуль, внешняя система) с несовместимым интерфейсом, который нужно адаптировать. |

---

### 3. Полезные нюансы и приёмы

1.  **Adapter vs. Decorator/Proxy**
    *   _Адаптер_ **меняет интерфейс** существующего объекта.
    *   _Декоратор_ **добавляет** обязанности объекту, не меняя его интерфейс.
    *   _Прокси_ **контролирует доступ** к объекту, не меняя его интерфейс.
2.  **Object Adapter vs. Class Adapter** (В Python чаще используется Object Adapter)
    *   **Object Adapter**: Использует **композицию** (содержит ссылку на `Adaptee`). Более гибок.
    *   **Class Adapter**: Использует множественное наследование (наследуется и от `Target`, и от `Adaptee`). Реже применяется в Python, требует наличия класса `Adaptee`.
3.  **Адаптация не только классов**: В Python адаптер может легко оборачивать функции, модули или даже результаты вызовов API.
4.  **Двусторонний Адаптер**: Редкий вариант, который позволяет адаптировать интерфейсы в обе стороны (объект A может использовать B, и B может использовать A через один адаптер). Обычно сложен в реализации.
5.  **Использование `typing.Protocol`**: Помогает формально определить `Target` интерфейс в Python, улучшая проверку типов и читаемость кода.
6.  **Адаптер по умолчанию (Default Adapter)**: Реализация `Target` интерфейса, которая предоставляет пустые или стандартные методы. Полезна, когда клиенту не всегда нужны все методы интерфейса.

---

### 4. Когда Адаптер не нужен

*   Интерфейсы **уже совместимы**.
*   **Можно легко изменить** код `Client` или `Adaptee`, чтобы они соответствовали друг другу (например, если вы контролируете оба).
*   Нужно **добавить** новую функциональность, а не просто изменить интерфейс (рассмотрите Декоратор).
*   Создание адаптера вносит излишнюю сложность для очень простого случая (например, адаптация одного метода с другим именем может быть проще через простую оберточную функцию).

---

### 5. Итого

**Адаптер** — отличный выбор, когда:

*   нужно заставить работать вместе классы или компоненты с **несовместимыми интерфейсами**,
*   хочется **переиспользовать** существующий класс/библиотеку, но её интерфейс неудобен или не соответствует ожиданиям клиента,
*   необходимо создать **единый, согласованный интерфейс** для работы с несколькими разными подсистемами или сторонними сервисами.