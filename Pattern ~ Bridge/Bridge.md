Окей, вот описание паттерна **Мост** (Bridge) в заданном Markdown-стиле.

---

### 1. Что такое «Мост» (Bridge)

**Мост** — структурный паттерн, который **разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию** — позволяя изменять их независимо друг от друга.

Это позволяет:

*   избежать "взрыва" количества классов, когда и абстракция, и реализация могут иметь несколько вариаций,
*   изменять внутреннюю реализацию (например, работу с разными ОС, API, базами данных), не затрагивая клиентский код, работающий с абстракцией,
*   расширять обе иерархии (абстракцию и реализацию) независимо.

`Клиент ──▶ Абстракция ──▶ Реализация`
*(Абстракция содержит ссылку на объект Реализации)*

#### Зачем он нужен

| Боль                                                                                              | Как помогает Bridge                                                                                                     |
| :------------------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------- |
| Класс разросся из-за множества вариаций (например, Фигура + Цвет: КрасныйКруг, СинийКруг...).      | Разделяем на иерархию Фигур (Абстракция) и иерархию СпособовОтрисовки/Цветов (Реализация). Фигура *содержит* Цвет. |
| Изменения в реализации (например, переход на новое API) требуют переписывания абстрактных классов. | Меняем только классы Реализации. Абстракция продолжает работать со старым интерфейсом Реализации.                       |
| Нужно добавить новую вариацию абстракции или реализации, не затрагивая другую часть.             | Добавляем новый подкласс в нужную иерархию (Абстракции или Реализации), не трогая другую.                               |

> ✂️ **Короткая аналогия** (и хватит): представьте **пульт управления** (Абстракция) и **телевизор** (Реализация). У вас может быть простой пульт или пульт с расширенными функциями (RefinedAbstraction). Телевизор может быть старый кинескопный или новый SmartTV (ConcreteImplementation). Паттерн Мост позволяет вам использовать _любой_ пульт с _любым_ телевизором (поддерживающим базовый интерфейс управления), просто "связав" их вместе во время настройки. Вы можете купить новый телевизор, не меняя пульт, или новый пульт, не меняя телевизор.

---

### 2. Мини‑теория: участники

| Роль                     | Суть                                                                                                      |
| :----------------------- | :-------------------------------------------------------------------------------------------------------- |
| **Abstraction**          | Определяет интерфейс высокого уровня для клиента. Хранит ссылку на объект `Implementation`.                   |
| **RefinedAbstraction**   | Расширяет интерфейс `Abstraction`, добавляя новые операции, которые опираются на базовый интерфейс.         |
| **Implementation**       | Определяет общий интерфейс для всех конкретных реализаций. Обычно это низкоуровневые операции.             |
| **ConcreteImplementation** | Реализует интерфейс `Implementation`, предоставляя конкретную логику (например, для определённой ОС, API). |
| **Client**               | Работает только с объектами `Abstraction`. Не знает о конкретных реализациях `Implementation`.            |

---

### 3. Полезные нюансы и приёмы

1.  **Bridge vs. Adapter**
    *   _Мост_ проектируется **заранее**, чтобы разделить компоненты, которые *должны* развиваться независимо.
    *   _Адаптер_ используется **постфактум**, чтобы заставить работать вместе *уже существующие* несовместимые интерфейсы.
2.  **Bridge vs. Strategy**
    *   Оба используют композицию и могут менять поведение объекта.
    *   _Стратегия_ обычно меняет *алгоритм* внутри одного объекта/контекста (как сделать что-то).
    *   _Мост_ разделяет большие компоненты системы, меняя *всю реализацию* для абстракции (что делает и как это реализовано на низком уровне). Часто `Abstraction` использует `Strategy` для делегирования части своей работы.
3.  **Выбор интерфейса Реализации**: Интерфейс `Implementation` должен быть достаточно минимальным и общим, чтобы скрыть детали платформы/API, но достаточно мощным, чтобы `Abstraction` могла выполнять свою работу.
4.  **Одна Абстракция, много Реализаций**: Часто есть только одна основная `Abstraction`, но множество `ConcreteImplementation` для разных платформ или API.
5.  **Динамическая смена Реализации**: `Abstraction` может позволять менять связанный объект `Implementation` во время выполнения.
6.  **Composition over Inheritance**: Мост является классическим примером принципа "предпочитайте композицию наследованию".

---

### 4. Когда Мост не нужен

*   Система **простая**, и разделение на абстракцию/реализацию только усложнит код.
*   Существует **только одна реализация**, и маловероятно, что появятся другие.
*   Абстракция и реализация **тесно связаны** и должны изменяться вместе.
*   Достаточно более простого паттерна (например, Стратегия).

---

### 5. Итого

**Мост** — мощный инструмент, когда:

*   нужно **избежать жёсткой привязки** абстракции к её реализации,
*   требуется изменять или расширять **абстракцию и реализацию независимо** друг от друга,
*   необходимо **скрыть детали реализации** (например, платформо-зависимый код) от клиентского кода,
*   требуется **избежать разрастания** иерархии классов из-за комбинации вариаций абстракции и реализации.