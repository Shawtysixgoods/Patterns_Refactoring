## Factory Method

### 1. Что такое «Фабричный метод» (Factory Method)

«Фабричный метод» — это порождающий паттерн, который делегирует **создание объектов** подклассам.  
Вместо того чтобы жёстко прописывать `new SomeClass()` в коде, мы описываем **шаг‑шаблон** (factory method).  
Подклассы решают, **какой конкретный объект** вернуть. Клиент знает лишь общий интерфейс продукта, но не знает его точный тип.

```
Клиент ──▶ Creator (вызывает factory_method) ──▶ ConcreteProduct
```
#### Зачем он нужен

|Боль|Как помогает паттерн|
|---|---|
|Куча `if/elif` для выбора нужного класса|Выносит выбор в отдельные классы‑фабрики|
|Нарушение OCP: добавили новый тип — лезем в клиентский код|Новые продукты → новые фабрики, клиент не меняем|
|Сложно тестировать/расширять создание|Лёгко подменять фабрику мок‑классом|

#### Какие проблемы решает

1. **Изоляция кода создания** (особенно полезно, когда конструктор громоздкий).
    
2. **Полиморфизм на уровне продуктов**: клиент оперирует интерфейсом, а не конкретикой.
    
3. **Расширяемость**: новые продукты добавляются через новые фабрики, не трогая остальной код.

#### Как строится (участники)

- **Product** — общий интерфейс/абстрактный класс создаваемых объектов.
    
- **ConcreteProductA/B…** — реальные классы.
    
- **Creator** — объявляет **factory_method()** и, чаще всего, содержит «бизнес‑логику», использующую Product.
    
- **ConcreteCreatorA/B…** — переопределяют factory_method() и возвращают нужный ConcreteProduct.
    

> Аналогия (коротко): ресторан (Creator) всегда подаёт «суп дня» (Product),  
> но шеф‑повара разных филиалов (ConcreteCreator) варят **разный** суп,  
> клиенту всё равно — он просто заказывает «суп дня».

### 4. Полезные нюансы и трюки

1. **Factory Method vs Abstract Factory**  
    _FM_ создаёт **один** семействованный объект; _AF_ — **целое семейство** взаимосвязанных продуктов.
    
2. **Статический метод‑фабрика** внутри класса‑продукта — частый, но не «каноничный» вариант; он нарушает SRP, но иногда удобен.
    
3. **Кеширование (Flyweight)**: factory_method может возвращать уже созданные объекты (пулы соединений, синглтоны).
    
4. **Типизация**: в Python удобно использовать `Protocol` или `typing.Self` (3.12+) для более строгих сигнатур.
    
5. **Ленивая загрузка плагинов**: можно импортировать модули через `importlib` при первом запросе провайдера, ускоряя старт приложения.
    

---

### 5. Когда НЕ стоит применять

- Создаваемый объект **тривиален** (один‑два аргумента) — лишний слой усложнит код.
    
- У вас **нет вариаций** продуктов и не планируется расширение.
    
- Производительность критична, а фабрика добавляет заметный оверхед (редко, но бывает в tight‑loop коде).
    

---

### 6. Итого

_Фабричный метод_ — это способ **прятать логику создания** за единым интерфейсом,  
оставляя клиенту «кнопку» _сделай‑мне‑что‑нибудь_, а детали отдаются в руки подклассов.  
В результате код чище, расширяемее и легче тестируется.  
Если вы чувствуете, что «с каждым новым типом растёт список `if/elif`», —  
самое время вынести их в **ConcreteCreator‑ы** и сказать: «Ну всё, у нас теперь Фабричный метод!»