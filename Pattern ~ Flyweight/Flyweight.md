Отлично, вот описание паттерна **Легковес** (Flyweight) в заданном Markdown-стиле.

---

### 1. Что такое «Легковес» (Flyweight)

**Легковес** — структурный паттерн, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. Он **экономит память**, **разделяя общее состояние** между множеством объектов вместо хранения одинаковых данных в каждом объекте.

Это позволяет:

*   **существенно сократить потребление памяти** при работе с большим количеством схожих объектов,
*   отделить **внутреннее (intrinsic)**, общее, неизменяемое состояние от **внешнего (extrinsic)**, контекстного, уникального состояния,
*   эффективно управлять пулом разделяемых объектов.

`Клиент ──▶ Фабрика Легковесов ──▶ Легковес (общее состояние)`
*(Клиент хранит/вычисляет внешнее состояние и передает его Легковесу при вызове)*

#### Зачем он нужен

| Боль                                                                                                  | Как помогает Flyweight                                                                                                      |
| :---------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- |
| Создание тысяч или миллионов мелких, но "тяжёлых" объектов (частицы, символы, тайлы) съедает всю RAM. | Создаём **один** объект-Легковес для каждого типа (например, для каждой буквы алфавита) и **переиспользуем** его многократно. |
| Объекты очень похожи, отличаются только контекстом (позиция, цвет, размер), но дублируют общие данные. | **Общие** данные (глиф символа, текстура тайла) храним в Легковесе (intrinsic state). **Контекст** (позиция на экране) передаём извне (extrinsic state). |
| Нужно как-то управлять этими разделяемыми объектами, чтобы не создавать дубликаты.                   | **Фабрика Легковесов** инкапсулирует создание и хранение пула Легковесов, выдавая существующие экземпляры по запросу.      |

> ✂️ **Короткая аналогия** (и хватит): Представьте **текстовый редактор**. Чтобы отобразить миллион букв 'A' на экране, редактор не создаёт миллион объектов, каждый из которых хранит форму (глиф), шрифт, начертание этой буквы. Он создаёт **один** объект `Символ_А` (Легковес) с этой **общей (intrinsic)** информацией. А когда нужно нарисовать 'A' в конкретном месте, редактор передаёт этому объекту **контекст (extrinsic)**: координаты (x, y), возможно, цвет или выделение. Сам объект `Символ_А` переиспользуется тысячи раз.

---

### 2. Мини‑теория: участники

| Роль                 | Суть                                                                                                                                  |
| :------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
| **Flyweight**        | **Интерфейс** или абстрактный класс, объявляющий метод(ы) для получения **внешнего состояния** (extrinsic state).                        |
| **ConcreteFlyweight**| **Реализует** интерфейс `Flyweight`. Хранит **внутреннее (intrinsic) состояние**. Объекты этого класса **разделяются** между клиентами.    |
| **FlyweightFactory** | **Создаёт и управляет** объектами `Flyweight`. Обеспечивает их разделение, возвращая существующий экземпляр или создавая новый, если его нет. Хранит **пул** легковесов. |
| **Client**           | **Хранит или вычисляет внешнее (extrinsic) состояние**. Использует `FlyweightFactory` для получения `Flyweight` и передаёт ему внешнее состояние при вызове методов. |
| *(UnsharedConcreteFlyweight)* | *(Опционально)* Класс, который не разделяется, но реализует интерфейс `Flyweight`. Используется, если некоторые объекты по какой-то причине не могут разделять состояние. |

---

### 3. Полезные нюансы и приёмы

1.  **Intrinsic vs. Extrinsic State**: Ключевое различие!
    *   **Intrinsic (Внутреннее)**: Состояние, не зависящее от контекста, **общее** для многих объектов, хранится *внутри* Легковеса. Должно быть **неизменяемым** (immutable) или изменяться крайне редко.
    *   **Extrinsic (Внешнее)**: Состояние, зависящее от контекста, **уникальное** для каждого использования Легковеса, хранится *вне* Легковеса (у Клиента) и **передаётся** в методы Легковеса как параметры.
2.  **Неизменяемость (Immutability)**: Внутреннее состояние Легковеса должно быть неизменяемым, так как объект используется совместно. Изменение этого состояния повлияет на всех клиентов.
3.  **Фабрика Легковесов**: Центральный элемент паттерна. Обычно использует словарь (хеш-таблицу) для хранения и быстрого поиска существующих Легковесов по ключу (часто на основе их внутреннего состояния).
4.  **Управление жизненным циклом**: Фабрика отвечает за создание Легковесов. Вопрос их удаления может быть сложным (когда Легковес больше никому не нужен?). Иногда используют слабые ссылки (`weakref` в Python) или ручное управление.
5.  **Состояние может быть объектом**: Внешнее состояние само по себе может быть инкапсулировано в отдельный объект "Контекст", который клиент передаёт Легковесу.
6.  **Комбинация с другими паттернами**: Легковес часто используется вместе с **Компоновщиком** (для представления листьев дерева, например, символов в структуре документа) или **Стратегией/Состоянием** (если объекты стратегий/состояний могут быть разделяемыми).

---

### 4. Когда Легковес не нужен

*   Приложение использует **небольшое количество** объектов, и экономия памяти несущественна.
*   Объекты **не имеют общего состояния** или оно незначительно.
*   Всё состояние объектов **уникально (extrinsic)** или часто изменяется (делая разделение невозможным или бессмысленным).
*   **Сложность**, вносимая разделением состояния и фабрикой, перевешивает выгоды от экономии памяти.

---

### 5. Итого

**Легковес** — это выбор №1 для **оптимизации памяти**, когда:

*   приложение должно поддерживать **огромное количество объектов**,
*   объекты имеют **значительную часть общего, неизменяемого состояния (intrinsic)**,
*   **уникальное состояние (extrinsic)** может быть отделено и передано объекту извне,
*   идентичность конкретного экземпляра объекта **не важна** для клиента (важно только его состояние и поведение).