### 1. Что такое «Одиночка» (Singleton)

**Одиночка** — это порождающий паттерн, гарантирующий, что **класс имеет ровно один экземпляр** и предоставляет глобальную точку доступа к нему.

`Клиент ──▶ Singleton.get_instance() ──▶ [ единственный объект ]`

_Ключевая идея:_ вместо того чтобы писать `obj = MyClass()` в каждом месте, мы зовём «фабрику‑доступ» (`get_instance`), а она либо создаёт объект первый раз, либо возвращает уже созданный.

#### Зачем он нужен

|Боль|Как помогает «Одиночка»|
|---|---|
|Нужно централизованное хранилище настроек|Один объект‑конфиг доступен всем модулям|
|Логгер плодится в каждом файле → дублирует ресурсы|Один экземпляр логгера пишет в файл потокобезопасно|
|Создание ресурса дорого (подключение к БД)|Подключаемся один раз, переиспользуем|

#### Какие проблемы решает

1. **Контроль над ресурсами** (файл, сокет, GPU‑сессия).
    
2. **Единая точка правды** — все читают/пишут в одно место.
    
3. **Ленивая инициализация** — объект создаётся «по требованию».
    

> Мини‑аналогия: роутер Wi‑Fi дома. Сколько бы устройств ни подключалось, физически роутер один.

### 4. Нюансы, трюки и подводные камни

|Нюанс|Пояснение|
|---|---|
|**Модули Python уже «почти» одиночки**|`import config` в разных местах возвращает один объект‑модуль. Иногда достаточно модуля вместо класса.|
|**Тестируемость**|Глобальное состояние усложняет юнит‑тесты. Используйте `Config._instance = None` в `setup()` для сброса.|
|**Многопоточность**|В CPython GIL частично спасает, но для надёжности ставьте `Lock`.|
|**Многопроцессность**|Каждый процесс получает свой экземпляр. Нужен IPC (SharedMemory, Redis, файл).|
|**Метакласс Singleton**|Элегантный способ: `class SingletonMeta(type): ...` и `class My(metaclass=SingletonMeta): pass`.|
|**Borg‑паттерн (shared state)**|Все экземпляры разделяют `__dict__`, но самих экземпляров несколько. Удобно, когда нужен общий стейт без проверки `is`.|

---

### 5. Когда НЕ стоит применять

- **Нужен чистый функциональный стиль** без скрытого состояния.
    
- Требуется **многократное создание** объекта с разными параметрами (Singleton не позволит).
    
- Код станет **трудно тестировать** или расширять — глобальное состояние быстро растёт и «течёт» по проекту.
    
- В DI‑фреймворках (FastAPI, Flask‑Injector) лучше явно прокинуть зависимость, чем прятать её в Singleton.
    

---

### 6. Итого

**Одиночка** — полезный инструмент, когда объект **по‑природе единственный**: конфиг, логгер, пул соединений.  
Главное — не превращать его в «помойку» глобального состояния и помнить о потоках и тестах.  
Если чувствуете, что класс создаётся _ровно один раз_ и к нему тянутся изо всех уголков — оформите это честно как Singleton, добавьте защиту от гонок, и проект скажет «спасибо».